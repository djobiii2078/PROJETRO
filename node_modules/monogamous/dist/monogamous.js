'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

var _os = require('os');

var _os2 = _interopRequireDefault(_os);

var _events = require('events');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _net = require('net');

var _net2 = _interopRequireDefault(_net);

var _minimist = require('minimist');

var _minimist2 = _interopRequireDefault(_minimist);

var _stampit = require('stampit');

var _stampit2 = _interopRequireDefault(_stampit);

/**
 * handles duplicate instance attempts
 * */
var server = (0, _stampit2['default'])().props({
    force: false,
    emitter: undefined
}).init(function () {
    var _this = this;

    var serve = undefined;
    var handleReboot = function handleReboot(data) {
        var parsed = undefined;
        try {
            parsed = JSON.parse(data.toString('utf-8'));
        } catch (err) {
            if (!(err instanceof SyntaxError)) {
                throw err;
            }
        }
        _this.emitter.emit('reboot', parsed);
    };
    var handleConnection = function handleConnection(conn) {
        conn.on('data', handleReboot);
    };
    var handleError = function handleError(err) {
        console.error('boot server failed', err);
    };
    var handleListening = function handleListening() {
        _this.emitter.emit('boot', _this.args);
    };
    var handleClose = function handleClose() {
        _this.emitter.emit('end');
    };

    var start = function start() {
        if (_this.force) {
            _this.emitter.emit('boot', _this.args);
            return;
        }
        _this.removeSocket();
        serve = _net2['default'].createServer(handleConnection);
        serve.listen(_this.socketPath());
        serve.on('listening', handleListening);
        serve.on('error', handleError);
        serve.on('close', handleClose);
    };
    this.startServer = start;
    this.end = function () {
        return serve.close();
    };
});

var client = (0, _stampit2['default'])().methods({
    //try to connect to socket and forward args to running instance
    //on error, it must need to boot
    connect: function connect() {
        var _this2 = this;

        var spath = this.socketPath();
        var _client = undefined;
        var handleConnection = function handleConnection() {
            //send data to previous instance and then shutdown
            _client.write(JSON.stringify(_this2.args), function () {
                _client.end();
                //not an error...
                process.exit(0);
            });
        };
        _client = _net2['default'].connect({ path: spath }, handleConnection);
        //unable to connect, so boot the app once our server starts
        _client.on('error', this.startServer);
    }

});

//boot strategy for windows
var win32 = (0, _stampit2['default'])().props({
    force: false
}).compose(client, server).methods({
    socketPath: function socketPath() {
        return '\\\\.\\pipe\\' + this.sock + '-sock}';
    },
    removeSocket: function removeSocket() {
        //nothing to do here
        return false;
    },
    boot: function boot() {
        this.connect();
    }
});

//boot strategy for everyone else
var defaultPlatform = (0, _stampit2['default'])().props({
    force: false
}).compose(client, server).methods({
    socketPath: function socketPath() {
        return _path2['default'].join(_os2['default'].tmpdir(), this.sock + '-' + process.env.USER + '.sock');
    },
    boot: function boot() {
        //fail fast
        if (this.force || !_fs2['default'].existsSync(this.socketPath())) {
            this.startServer();
        } else {
            this.connect();
        }
    },
    removeSocket: function removeSocket() {
        var spath = this.socketPath();
        if (_fs2['default'].existsSync(spath)) {
            try {
                _fs2['default'].unlinkSync(spath);
            } catch (err) {
                /*
                 *
                 * Ignore ENOENT errors in case the file was deleted between the exists
                 * check and the call to unlink sync. This occurred occasionally on CI
                 * which is why this check is here.
                 * */
                if (err.code !== 'ENOENT') {
                    throw err;
                }
            }
        }
    }
});

exports['default'] = (0, _stampit2['default'])().props({
    //the name of the app to name the socket/pipe
    sock: undefined,
    //force instance to start
    force: false
}).init(function (_ref) {
    var args = _ref.args;

    if (!this.sock) {
        throw new Error('`sock` is required');
    }
    //compose event emitter to workaround stampit undefined return
    var emitter = this.emitter = new _events.EventEmitter();
    var platform = undefined;
    this.on = emitter.on.bind(emitter);
    this.once = emitter.once.bind(emitter);
    this.removeListener = emitter.removeListener.bind(emitter);
    this.removeAllListeners = emitter.removeAllListeners.bind(emitter);
    this.emit = emitter.emit.bind(emitter);

    /**
     * call this to emit proper events
     * based on state of app (running/not)
     * */
    this.boot = (function (bootArgs) {
        args.push((0, _minimist2['default'])(process.argv.slice(2)));
        args.push(bootArgs);
        var argv = Object.assign.apply(Object, [{}].concat(_toConsumableArray(args)));
        if (process.platform === 'win32') {
            platform = win32({
                sock: this.sock,
                emitter: emitter,
                force: this.force,
                args: argv
            });
        } else {
            platform = defaultPlatform({
                sock: this.sock,
                emitter: emitter,
                force: this.force,
                args: argv
            });
        }

        // boot it!
        platform.boot();
    }).bind(this);

    this.end = function () {
        if (platform) {
            return platform.end();
        }
        this.emit('end');
    };
});
module.exports = exports['default'];